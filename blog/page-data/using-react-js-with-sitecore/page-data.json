{"componentChunkName":"component---src-templates-blog-post-js","path":"/using-react-js-with-sitecore/","result":{"data":{"site":{"siteMetadata":{"title":"Albsugy Blog"}},"markdownRemark":{"id":"9b770a28-c430-5e68-b22e-8d5f457624e5","excerpt":"Getting Started The React sample supports running in all JSS application modes . For example, to start the app in disconnected mode, run  to build the app and…","html":"<h3>Getting Started</h3>\n<p>The React sample supports running in all <a href=\"https://jss.sitecore.com/docs/fundamentals/application-modes\">JSS application modes</a> . For example, to start the app in disconnected mode, run <code class=\"language-text\">jss start</code> to build the app and open a browser to view it.</p>\n<h3>Routing + State Management</h3>\n<p>The sample app uses dynamic routing based on the <a href=\"https://jss.sitecore.com/docs/fundamentals/services/layout-service\">Layout Service</a> (or local route data files in disconnected mode), and uses route/navigation changes to trigger app state changes. Thus tracing the primary execution flow should begin with the route configuration.</p>\n<h4>Client-side routing</h4>\n<p>Starting from the main client-side entry point of the app in index.js:</p>\n<ul>\n<li>In <code class=\"language-text\">index.js</code> SSR data and state is handled and rendering is passed off to <AppRoot></li>\n<li>In <code class=\"language-text\">AppRoot.js</code> the router is configured to respond to app routes and pass them off to <RouteHandler></li>\n<li>In <code class=\"language-text\">RouteHandler.js</code>, Layout Service data is acquired for the current route, and the route and language state of the app are maintained. Actual app markup rendering is passed off to the <Layout> component.</li>\n<li>In <code class=\"language-text\">Layout.js</code>, the shell HTML and global elements of the JSS app, along with its root <Placeholder>(s) are rendered</li>\n<li>The remaining structure of the route is defined by the route data, which defines which components - and their content data - live in each placeholder.</li>\n</ul>\n<h4>Server-side routing</h4>\n<p>When the React app is pre-rendered by a Node server, thus returning HTML to the client in the initial response, the route data flow is similar to client-side routing but has a few key differences.</p>\n<ol>\n<li>[Integrated mode only] Sitecore will receive the request, parse the route server-side, and determine whether the requested item will be handled by a JSS application, and thus which bundle to execute.</li>\n<li>[Headless mode only] A request is received by the Node SSR proxy and passed on to a Sitecore layout service</li>\n<li>The Node host will invoke the <code class=\"language-text\">renderView</code> function in the <code class=\"language-text\">server/server.js</code>. The function arguments include the route data / Layout Service output.</li>\n<li>\n<p>The <code class=\"language-text\">renderView</code> function performs the following steps:</p>\n<ul>\n<li>Receive the data to use when server-side rendering (layout service, dictionary)</li>\n<li>Sets the SSR data into the app’s initial state using <code class=\"language-text\">setServerSideRenderingState()</code></li>\n<li>Render the app to HTML using React’s SSR tools</li>\n<li>Embed the rendered app within its <code class=\"language-text\">index.html</code> template and set metadata and SSR state. The SSR state <code class=\"language-text\">(window.__JSS_STATE__)z</code> is used to rehydrate the app state on the client, preventing the need to call Layout Service for initial route data.</li>\n<li>Invoke the render callback function with the final HTML</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>Note: the sample app by default uses Apollo GraphQL tools to render the app to HTML on the server <code class=\"language-text\">renderToStringWithData()</code>. This allows server-side rendering with the async results of GraphQL queries evaluated. If not using GraphQL, the more pedestrian <code class=\"language-text\">ReactDOMServer.renderToString()</code> can be used instead.</p>\n</blockquote>\n<h3>App Build System</h3>\n<p>The JSS React app includes some build system helpers to make working with the app easier.</p>\n<h4>Scaffolding</h4>\n<p>Scaffolding a new JSS React component is provided via <code class=\"language-text\">jss scaffold &lt;componentName&gt;</code>. The scaffold is defined by <code class=\"language-text\">scripts/scaffold-component.js</code>, and is fully customizable to your needs. Scaffolding creates the React component and the disconnected component definition files, then provides helpful feedback about what to do to make your component work.</p>\n<h4>Dynamic Config Generation</h4>\n<p>The JSS app needs to be able to read aspects of the JSS configuration, such as the current Layout Service endpoint config. To accomplish this, before a build runs the <code class=\"language-text\">scripts/generate-config.js</code> script is run which dynamically assembles the <code class=\"language-text\">src/temp/config.js</code> file that the app can then import when it needs config access. This script is fully customizable - or removable - if you have different configuration requirements.</p>\n<h4>Dynamic Component Factory Module</h4>\n<p>When a build is started, the JSS React app will automatically generate the component factory, a mapping between JSS component names and their React component implementations. This file, <code class=\"language-text\">src/temp/componentFactory.js</code>, is generated using conventions for defining your JSS components. This is useful to avoid needing to manually register new components. When the app is running locally, it is also smart enough to watch for new components and update the module. This auto generation is defined in <code class=\"language-text\">scripts/generate-component-factory.js</code>, and is fully customizable.</p>\n<p>This convenience feature is entirely removable in three steps:</p>\n<ol>\n<li>Remove <code class=\"language-text\">componentFactory.js</code> from .gitignore in the <code class=\"language-text\">src/temp/.gitignore</code>.</li>\n<li>Delete <code class=\"language-text\">/scripts/generate-component-factory.js</code></li>\n<li>Remove the reference to the deleted script from <code class=\"language-text\">/scripts/bootstrap.js</code></li>\n</ol>\n<h4>Disconnected Mode Support</h4>\n<p>The JSS <a href=\"https://jss.sitecore.com/docs/fundamentals/application-modes\">disconnected mode</a> enables development of JSS apps using a local mock version of the Sitecore JSS services - Layout Service and Dictionary Service. This is accomplished by running a small Express app on a different port - 3042 by default - that hosts the mock services <code class=\"language-text\">scripts/disconnected-mode-proxy.js</code>. <code class=\"language-text\">create-react-app</code> is then configured to <code class=\"language-text\">proxy</code> (the proxy section in <code class=\"language-text\">package.json</code>) requests to API paths to this mock service layer. The mock services layer is powered by a JSS manifest file that is automatically generated from your disconnected data definitions (<code class=\"language-text\">/data</code>, <code class=\"language-text\">/sitecore/definitions</code>). This manifest is automatically regenerated when the data is changed and live reloading is supported.</p>\n<h3>Using GraphQL + React</h3>\n<p><a href=\"https://graphql.org/\">GraphQL</a> is a popular and extremely powerful API platform that is well suited to JSS apps’ data needs when they extend beyond simple route data. <a href=\"https://jss.sitecore.com/docs/fundamentals/services/graphql\">Sitecore GraphQL</a> is supported to enable accessing content or other custom data schemas (for example, aggregating an existing set of backend REST services).</p>\n<blockquote>\n<p>Sitecore GraphQL does not come with a disconnected mock service, so it can only operate with a JSS app in Connected, Integrated, or Headless application modes. If disconnected GraphQL functionality is required, <a href=\"https://github.com/apollographql/graphql-tools\">graphql-tools</a> has very powerful GraphQL mocking capabilities.</p>\n</blockquote>\n<p>Refer to the <a href=\"https://jss.sitecore.com/docs/fundamentals/services/graphql\">JSS + GraphQL</a> documentation to understand the overall capabilities first - we’re only talking about React and Connected GraphQL specifically here. Integrated GraphQL works at the server level, so it is identical in any supported frontend framework.</p>\n<p>The React sample app makes use of the <a href=\"https://www.apollographql.com/docs/react/\">Apollo GraphQL client</a>. Usage is pretty simple: follow the <code class=\"language-text\">react-apollo</code> documentation, but instead of using the <code class=\"language-text\">graphql</code> higher order component, use the JSS-specific <code class=\"language-text\">GraphQLData</code> HOC instead. This service has the same API as Apollo, but performs some JSS-specific operations to make it more compatible with Sitecore.</p>\n<blockquote>\n<p>Complete examples of using connected and integrated GraphQL are provided with the sample app and are heavily commented, for example <code class=\"language-text\">src/components/GraphQL-ConnectedDemo</code>. Please refer to these samples for implementation details.</p>\n</blockquote>\n<h4>Sitecore Context Access</h4>\n<p>JSS ships with a React higher order component that can inject the Sitecore context - in other words route-level data, as opposed to component-level data - into any component. Common examples of needing context data might be to get at page title or meta keywords fields stored on the route level, or to conditionally alter rendering when in Experience Editor mode. Here’s an abbreviated example of using it:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> withSitecoreContext <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@sitecore-jss/sitecore-jss-react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">MyComponent</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Page editing<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>sitecoreContext<span class=\"token punctuation\">.</span>pageEditing<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// wrap MyComponent in the HOC (note the double function invocation - important)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token function\">withSitecoreContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>MyComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Usage of <code class=\"language-text\">withSitecoreContext()</code> is dependent on having a <code class=\"language-text\">&lt;SitecoreContext&gt;</code> component wrapping anything using <code class=\"language-text\">withSitecoreContext()</code> that maintains a <code class=\"language-text\">SitecoreContextFactory</code> instance in the component hierarchy. Here’s an example of that:</p>\n<p>Root.js (the root component in your app)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> SitecoreContext <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@sitecore-jss/sitecore-jss-react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> componentFactory <span class=\"token keyword\">from</span> <span class=\"token string\">'./componentFactory'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> SitecoreContextFactory <span class=\"token keyword\">from</span> <span class=\"token string\">'./SitecoreContextFactory'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>SitecoreContext contextFactory<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>SitecoreContextFactory<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>YourAppsComponentsHere <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>SitecoreContext<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">SitecoreContextFactory.js</code> (creates and configures the context factory instance; imported above)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> SitecoreContextFactory <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@sitecore-jss/sitecore-jss-react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SitecoreContextFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The final piece of using <code class=\"language-text\">withSitecoreContext()</code> is to ensure that the <code class=\"language-text\">SitecoreContextFactory</code> is updated when the Sitecore context changes. This could be when the route changes in your app, or when server-side rendering passes down a state object - any time new layout data is pulled from Sitecore and rendered. To accomplish this, we import our <code class=\"language-text\">SitecoreContextFactory</code>, which due to ES6 module semantics is essentially a singleton so it can store state.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> SitecoreContextFactory <span class=\"token keyword\">from</span> <span class=\"token string\">\"boot/SitecoreContextFactory\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> routeData <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getRouteData</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// makes a request for new route data, for example</span>\n\n<span class=\"token comment\">// push the route data's context into the context factory</span>\nSitecoreContextFactory<span class=\"token punctuation\">.</span><span class=\"token function\">setSitecoreContext</span><span class=\"token punctuation\">(</span>routeData<span class=\"token punctuation\">.</span>sitecore<span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4>UI Components</h4>\n<p>UI components are the most important part of the JSS app. Thankfully, they are no different from any other React component - except that they are dynamically added inside a <code class=\"language-text\">Placeholder</code> component, which provides them with an ambient <code class=\"language-text\">fields</code> prop.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Text <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@sitecore-jss/sitecore-jss-react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Welcome</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> fields <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>Text field<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>fields<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Welcome<span class=\"token punctuation\">;</span></code></pre></div>\n<p>While the Welcome component is written as a stateless functional component because there is no internal component state or need for lifecycle methods, you can also use the ES6 class syntax and extend from <code class=\"language-text\">React.Component</code>. Generally speaking, JSS does not place any limitations on the usage of normal React conventions.</p>\n<h4>Handling Sitecore Field Types</h4>\n<p>You probably noticed the <code class=\"language-text\">&lt;Text /&gt;</code> component being used above. It is a special component that comes with JSS and as a helper for rendering the field value properly for editing inside Experience Editor. There are a number of helpers for different field types, such as images, dates, and rich text fields. Consult the Styleguide page in the sample app for working live examples of all these field types.</p>","frontmatter":{"title":"Using React.js with Sitecore","date":"March 07, 2019","description":"A practical sample that demonstrates many patterns of how to use JSS with React. It is designed to have just enough dependencies that Sitecore features can function."}}},"pageContext":{"slug":"/using-react-js-with-sitecore/","previous":{"fields":{"slug":"/zero-config-javascript-app-uisng-parcel-js/"},"frontmatter":{"title":"Zero Config JavaScript App using ParcelJS"}},"next":{"fields":{"slug":"/build-react-library-using-rollup/"},"frontmatter":{"title":"Build React Library using Rollup"}}}}}